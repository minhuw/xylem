# YCSB Workload B: Read Mostly
#
# Application Example: Photo tagging; add a tag is an update, but most operations are to read tags
#
# Characteristics:
# - 95% reads, 5% updates
# - Zipfian request distribution (hot keys)
# - 1 million record keyspace
# - Values: 1KB (simulating 10 fields × 100 bytes each)
#
# This workload represents a read-heavy cache scenario, typical for applications
# where data is read much more frequently than it is written.

[experiment]
name = "ycsb-workload-b"
description = "YCSB Workload B: Read Mostly (95% read, 5% update)"
duration = "60s"
seed = 42

[target]
address = "127.0.0.1:6379"
protocol = "redis"
transport = "tcp"

# Workload Configuration
[workload]
# Key space: 1 million records with Zipfian distribution
[workload.keys]
strategy = "zipfian"
n = 1000000          # recordcount=1000000
theta = 0.99         # YCSB default (hot-key pattern)
value_size = 1000    # fieldcount=10 × fieldlength=100

# Operation Mix: 95/5 read/update
[workload.operations]
strategy = "weighted"

[[workload.operations.commands]]
name = "get"
weight = 0.95  # readproportion=0.95

[[workload.operations.commands]]
name = "set"
weight = 0.05  # updateproportion=0.05

# Load Pattern: Constant rate
[workload.pattern]
type = "constant"
rate = 1000000.0  # 1M ops/sec (read-heavy workloads typically achieve higher throughput)

# Traffic Configuration
[[traffic_groups]]
name = "workload-b"
threads = [0, 1, 2, 3]           # Use 4 threads
connections_per_thread = 25      # 100 total connections
max_pending_per_connection = 10  # Pipelining for throughput

[traffic_groups.policy]
type = "fixed-rate"
rate = 20000.0

[traffic_groups.sampling_policy]
type = "limited"
rate = 1.0           # Sample 100% of requests
max_samples = 100000 # Limit stored samples

# Output Configuration
[output]
format = "json"
file = "/tmp/ycsb-workload-b.json"
real_time = true
